# 정렬

## 삽입 정렬(insertion sort)

- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 평균 시간 복잡도는 O(n<sup>2</sup>)으로 느린 편이지만 구현하기가 쉬움

### 핵심 이론

- 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것

### 수행 방식

1. 현재 index에 있는 데이터 값을 선택함
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색함
3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행함
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행함
5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복함

&nbsp; 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색(binary search)과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있음

## 퀵 정렬(quick sort)

- `기준값(pivot)`을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
- 기준값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미침
- 평균적인 시간 복잡도는 O(nlogn)

### 핵심 이론

- pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것

### 정렬 과정

1. 데이터를 분할하는 pivot을 설정함
2. pivot을 기준으로 디음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리함
   1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 한 칸 이동함
   2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 한 칸 이동함
   3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 한 칸씩 이동함
   4. start와 end가 만날 때까지 이를 반복함
   5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 적으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입함
3. 분리 집합에서 각각 다시 pivot을 선점함
4. 분리 집합이 1개 이하가 될 때까지 1~3을 반복함
