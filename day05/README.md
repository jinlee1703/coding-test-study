# 정렬

## 정렬 알고리즘 정의

- `버블(bubble)`: 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식
- `선택(selection)`: 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
- `삽입(insertion)`: 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
- `퀵(quick)`: pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
- `병합(merge)`: 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
- `기수(radix)`: 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식

## 버블 정렬

### 핵심 이론

- 두 인접한 데이터의 크기를 비교해 정렬하는 방법
- 간단하게 구현할 수 있으나, 시간 복잡도는 O(n<sup>2</sup>)으로 다른 정렬 알고리즘보다 속도가 느린 편
- loop를 돌면서 인접한 데이터 간의 swap 연산으로 정렬함

### 정렬 과정

1. 비교 연산이 필요한 루프 범위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다. (부합하지 않을 경우 swap 연산을 수행하지 않음)
4. 루프 범위가 끝날 때까지 `2`~`3`을 수행한다.
5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때까지 `1`~`5`를 반복한다.

&nbsp; 만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 그 영역 뒤에 잇는 데이터가 모두 정렬되었다는 의미이므로 프로세스를 종료해도 된다.

## 선택 정렬

### 핵심 이론

- 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n<sup>2</sup>)으로 효율적이지 않음 => 코딩 테스트에서 자주 사용되지 않음

### 정렬 과정

1. 남은 정렬 부분에서 최솟값 또는 최댓값(정렬 기준)을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
3. 가장 앞에 있는 **데이터의 위치**를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
4. 전체 데이터 크기와 index가 동일해질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

&nbsp; 선택 정렬 자체를 묻는 코딩 테스트 문제는 잘 나오지 않지만, 이 원리를 응용하는 문제는 나올 수 있으므로 선택 정렬이 어떤 원리로 작동하는지 알아두자.
